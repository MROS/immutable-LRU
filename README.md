本專案研究持久化 LRU 快取的資料結構以及實作

## 什麼是持久化

持久化（persistent）與不可變（immutable）這兩個術語經常被交替使用，本文中不打算詳述兩者的微妙差異，而是在定義持久化之後，在後文統一使用持久化這個術語。

### 定義
持久化（persistent）這個詞存在歧義，有時候它形容一個東西可以儲存進硬碟，斷電重啓之後依然可以存取。但在此處，我們採用它的另一個意思，當它修飾資料結構時，代表一個資料結構的過去版本是可以存取的。

#### 資料結構的版本

### 例子

## 轉換技巧

有些通用技巧，能將一般資料結構轉換爲持久化的形式，以下逐個介紹。

### 胖節點（fat node）

### 路徑複製

### DSST 方法

透過同時使用胖節點跟路徑複製兩個技巧，我們能夠得到一種均攤之後空間跟時間複雜度都只有額外 O(1) 負擔的算法。

#### 半持久
- p = 節點最大入度（亦即有多少指針指向該節點）
<!-- 僅先概述 -->
在每個節點內新增一個長度爲 p 的改動陣列（modification array）。當我們試圖去修改一個節點時，如果該節點的改動陣列未滿，則在改動陣列中添加一個改動記錄，該記錄包含改動的域名跟值。如果該節點的改動陣列已滿，則複製一個新的節點，其域值處於最新的狀態，而改動陣列爲空。
<!-- 先寫下證明 -->
以位能法來進行均攤分析空間複雜度，設位能爲所有活節點（TODO: 定義活節點）中改動陣列的使用量，顯然，此位能永不爲負。

1. 修改一個節點時，假設改動陣列未滿，則位能加一，由於沒有新增節點，真實花費 $c = 0$。均攤花費 $\hat{c} = c + 1 = 1$

2. 若改動陣列已滿，假設總共發生 k 個聯動複製，，另一方面，每個複製都會導致指向原節點的父節點指針發生改動，總計會發生 1（初始的第一次修改） + k * p （複製所導致的聯動修改），這些父節點分爲兩種：
    1. 改動陣列已滿。共有 k 個，因爲我們已知最終發生了 k 個聯動複製。複製都將導致原滿活節點死去，被空活節點取代，位能減少 $kp$。
    2. 改動陣列未滿。數量爲總數減去第一種的數量 $(1 + kp) - k = 1 + (p-1)k$ ，使每個改動使陣列用量加一，故位能增加 $1 + (p-1)k$。

    兩者的位能總和爲 $(1 + (p-1)k) - kp = 1-k$。

    由於複製了 k 個節點，真實花費 $c = k$，均攤花費 $\hat{c} = c + 1-k = k + 1-k = 1$。

每次修改的均攤空間複雜度爲

<!-- 想法 -->
要多少次改動纔會導致一次複製？

當陣列滿時，一個改動會引發 p 個聯動改動。

盡可能最大化的利用聯動改動的效果，能夠做到什麼程度？

假設當前所有節點的改動陣列均爲空，當我們對同一個節點進行 p + 1 次改動時，將得以製造一次聯動改動。

#### 全持久（）